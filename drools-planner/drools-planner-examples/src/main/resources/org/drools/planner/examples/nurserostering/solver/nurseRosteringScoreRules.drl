package org.drools.planner.examples.nurserostering.solver;
    dialect "java"

import org.drools.planner.core.score.calculator.HardAndSoftConstraintScoreCalculator;
import org.drools.planner.core.score.constraint.IntConstraintOccurrence;
import org.drools.planner.core.score.constraint.ConstraintType;

import org.drools.planner.examples.nurserostering.domain.DayOfWeek;
import org.drools.planner.examples.nurserostering.domain.Employee;
import org.drools.planner.examples.nurserostering.domain.EmployeeAssignment;
import org.drools.planner.examples.nurserostering.domain.NurseRoster;
import org.drools.planner.examples.nurserostering.domain.Pattern;
import org.drools.planner.examples.nurserostering.domain.Shift;
import org.drools.planner.examples.nurserostering.domain.ShiftDate;
import org.drools.planner.examples.nurserostering.domain.ShiftType;
import org.drools.planner.examples.nurserostering.domain.ShiftTypeSkillRequirement;
import org.drools.planner.examples.nurserostering.domain.Skill;
import org.drools.planner.examples.nurserostering.domain.SkillProficiency;
import org.drools.planner.examples.nurserostering.domain.contract.Contract;
import org.drools.planner.examples.nurserostering.domain.contract.BooleanContractLine;
import org.drools.planner.examples.nurserostering.domain.contract.ContractLine;
import org.drools.planner.examples.nurserostering.domain.contract.ContractLineType;
import org.drools.planner.examples.nurserostering.domain.contract.MinMaxContractLine;
import org.drools.planner.examples.nurserostering.domain.request.DayOffRequest;
import org.drools.planner.examples.nurserostering.domain.request.DayOnRequest;
import org.drools.planner.examples.nurserostering.domain.request.ShiftOffRequest;
import org.drools.planner.examples.nurserostering.domain.request.ShiftOnRequest;
import org.drools.planner.examples.nurserostering.domain.solver.EmployeeConsecutiveAssignment;
import org.drools.planner.examples.nurserostering.domain.solver.EmployeeConsecutiveAssignmentEnd;
import org.drools.planner.examples.nurserostering.domain.solver.EmployeeConsecutiveAssignmentStart;

// @author Geoffrey De Smet

global HardAndSoftConstraintScoreCalculator scoreCalculator;

// ############################################################################
// Hard constraints
// ############################################################################

// All demanded shifts must be assigned to a nurse
rule "requiredEmployeeSizePerShift"
    when
        $shift : Shift(requiredEmployeeSize > 0, $requiredEmployeeSize : requiredEmployeeSize)

        $totalEmployeeSize : Number(intValue != $requiredEmployeeSize) from accumulate(
            $assignment : EmployeeAssignment(shift == $shift),
            count($assignment)
        )
    then
        insertLogical(new IntConstraintOccurrence("requiredEmployeeSizePerShift", ConstraintType.NEGATIVE_HARD,
                Math.abs($requiredEmployeeSize - $totalEmployeeSize.intValue()),
                $shift));
end

// a nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.
rule "oneShiftPerDay"
    when
        $leftEmployeeAssignment : EmployeeAssignment($leftId : id, $employee : employee, $shiftDate : shiftDate)
        $rightEmployeeAssignment : EmployeeAssignment(employee == $employee, shiftDate == $shiftDate, id > $leftId)
    then
        insertLogical(new IntConstraintOccurrence("oneShiftPerDay", ConstraintType.NEGATIVE_HARD,
                1,
                $leftEmployeeAssignment, $rightEmployeeAssignment));
end

// ############################################################################
// Soft constraints
// ############################################################################

// Minimum number of assignments
rule "minimumTotalAssignments"
    when
        $contractLine : MinMaxContractLine(
            contractLineType == ContractLineType.TOTAL_ASSIGNMENTS, minimumEnabled == true,
            $contract : contract, $minimumValue : minimumValue
        )
        $employee : Employee(contract == $contract)
        $totalAssignmentSize : Number(intValue < $minimumValue) from accumulate(
            $assignment : EmployeeAssignment(employee == $employee),
            count($assignment)
        )
    then
        insertLogical(new IntConstraintOccurrence("minimumTotalAssignments", ConstraintType.NEGATIVE_SOFT,
                Math.abs($minimumValue - $totalAssignmentSize.intValue()),
                $employee));
end

// Maximum number of assignments
rule "maximumTotalAssignments"
    when
        $contractLine : MinMaxContractLine(
            contractLineType == ContractLineType.TOTAL_ASSIGNMENTS, maximumEnabled == true,
            $contract : contract, $maximumValue : maximumValue
        )
        $employee : Employee(contract == $contract)
        $totalAssignmentSize : Number(intValue > $maximumValue) from accumulate(
            $assignment : EmployeeAssignment(employee == $employee),
            count($assignment)
        )
    then
        insertLogical(new IntConstraintOccurrence("maximumTotalAssignments", ConstraintType.NEGATIVE_SOFT,
                Math.abs($totalAssignmentSize.intValue() - $maximumValue),
                $employee));
end

rule "insertEmployeeConsecutiveAssignmentStart"
        salience 2 // Do these rules first (optional, for performance)
    when
        EmployeeAssignment(
            $employee : employee,
            $dayIndex : shiftDateDayIndex,
            $shiftDate : shiftDate
        )
        // The first day has no working day before it
        not EmployeeAssignment(employee == $employee, shiftDateDayIndex == ($dayIndex - 1))
    then
        insertLogical(new EmployeeConsecutiveAssignmentStart($employee, $shiftDate));
end
rule "insertEmployeeConsecutiveAssignmentEnd"
        salience 2 // Do these rules first (optional, for performance)
    when
        EmployeeAssignment(
            $employee : employee,
            $dayIndex : shiftDateDayIndex,
            $shiftDate : shiftDate
        )
        // The last day has no working day after it
        not EmployeeAssignment(employee == $employee, shiftDateDayIndex == ($dayIndex + 1))
    then
        insertLogical(new EmployeeConsecutiveAssignmentEnd($employee, $shiftDate));
end
rule "insertEmployeeConsecutiveAssignment"
        salience 1 // Do these rules first (optional, for performance)
    when
        EmployeeConsecutiveAssignmentStart(
            $employee : employee,
            $firstShiftDate : shiftDate,
            $firstDayIndex : shiftDateDayIndex
        )

        EmployeeConsecutiveAssignmentEnd(
            employee == $employee,
            shiftDateDayIndex >= $firstDayIndex,
            $lastShiftDate : shiftDate,
            $lastDayIndex : shiftDateDayIndex
        )

        // There are no free days between the first and last day
        not EmployeeConsecutiveAssignmentEnd(
            employee == $employee,
            shiftDateDayIndex >= $firstDayIndex && < $lastDayIndex
        )
    then
        insertLogical(new EmployeeConsecutiveAssignment($employee, $firstShiftDate, $lastShiftDate));
end

// Minimum number of consecutive working days
rule "minimumConsecutiveWorkingDays"
    when
        $contractLine : MinMaxContractLine(
            contractLineType == ContractLineType.CONSECUTIVE_WORKING_DAYS, minimumEnabled == true,
            $contract : contract, $minimumValue : minimumValue
        )
        $employee : Employee(contract == $contract)

        $employeeConsecutiveAssignment : EmployeeConsecutiveAssignment(
            employee == $employee,
            dayLength < $minimumValue,
            $dayLength : dayLength
        )
    then
        insertLogical(new IntConstraintOccurrence("minimumConsecutiveWorkingDays", ConstraintType.NEGATIVE_SOFT,
                ($minimumValue - $dayLength) * $contractLine.getMinimumWeight(),
                $employeeConsecutiveAssignment));
end

// Maximum number of consecutive working days
rule "maximumConsecutiveWorkingDays"
    when
        $contractLine : MinMaxContractLine(
            contractLineType == ContractLineType.CONSECUTIVE_WORKING_DAYS, maximumEnabled == true,
            $contract : contract, $maximumValue : maximumValue
        )
        $employee : Employee(contract == $contract)

        $employeeConsecutiveAssignment : EmployeeConsecutiveAssignment(
            employee == $employee,
            dayLength > $maximumValue,
            $dayLength : dayLength
        )
    then
        insertLogical(new IntConstraintOccurrence("maximumConsecutiveWorkingDays", ConstraintType.NEGATIVE_SOFT,
                ($dayLength - $maximumValue) * $contractLine.getMaximumWeight(),
                $employeeConsecutiveAssignment));
end

// Minimum number of consecutive free days
//rule "minimumConsecutiveFreeDays"
//    when
//        $contractLine : MinMaxContractLine(
//            contractLineType == ContractLineType.CONSECUTIVE_FREE_DAYS, minimumEnabled == true,
//            $contract : contract, $minimumIndexDiff : minimumIndexDiff
//        )
//        $employee : Employee(contract == $contract)
//
//        // The first day ...
//        $firstShiftDate : ShiftDate($firstDayIndex : dayIndex)
//        not EmployeeAssignment(employee == $employee, shiftDate == $firstShiftDate)
//        // ... has no free day before it
//        (
//            exists EmployeeAssignment(employee == $employee, shiftDateDayIndex == ($firstDayIndex - 1))
//            or not ShiftDate(dayIndex == ($firstDayIndex - 1))
//        )
//
//        // The last day ...
//        $lastShiftDate : ShiftDate(
//            dayIndex > $firstDayIndex,
//            dayIndex < ($firstDayIndex + $minimumIndexDiff), // Too few days
//            $lastDayIndex : dayIndex)
//        not EmployeeAssignment(employee == $employee, shiftDate == $lastShiftDate)
//        // ... has no free day after it
//        (
//            exists EmployeeAssignment(employee == $employee, shiftDateDayIndex == ($lastDayIndex + 1))
//            or not ShiftDate(dayIndex == ($lastDayIndex + 1))
//        )
//
//        // There are no working days between the first and last day
//        not EmployeeAssignment(employee == $employee, shiftDateDayIndex  > $firstDayIndex && < $lastDayIndex)
//    then
//        insertLogical(new IntConstraintOccurrence("minimumConsecutiveFreeDays", ConstraintType.NEGATIVE_SOFT,
//                ($firstDayIndex + $minimumIndexDiff - $lastDayIndex) * $contractLine.getMinimumWeight(),
//                $employee, $firstDayIndex, $lastDayIndex));
//end

// Maximum number of consecutive free days
// TODO

// Maximum number of consecutive working weekends
// TODO

// Complete weekends
// TODO

// Single assignment per day
// TODO

// Two free days after a night shift
// TODO

// Requested day on/off
rule "dayOffRequest"
    when
        $dayOffRequest : DayOffRequest($employee : employee, $shiftDate : shiftDate, $weight : weight)
        $employeeAssignment : EmployeeAssignment(employee == $employee, shiftDate == $shiftDate)
    then
        insertLogical(new IntConstraintOccurrence("dayOffRequest", ConstraintType.NEGATIVE_SOFT,
                $weight,
                $dayOffRequest, $employeeAssignment));
end
rule "dayOnRequest"
    when
        $dayOnRequest : DayOnRequest($employee : employee, $shiftDate : shiftDate, $weight : weight)
        not EmployeeAssignment(employee == $employee, shiftDate == $shiftDate)
    then
        insertLogical(new IntConstraintOccurrence("dayOnRequest", ConstraintType.NEGATIVE_SOFT,
                $weight,
                $dayOnRequest));
end

// Requested shift on/off
rule "shiftOffRequest"
    when
        $shiftOffRequest : ShiftOffRequest($employee : employee, $shift : shift, $weight : weight)
        $employeeAssignment : EmployeeAssignment(employee == $employee, shift == $shift)
    then
        insertLogical(new IntConstraintOccurrence("shiftOffRequest", ConstraintType.NEGATIVE_SOFT,
                $weight,
                $shiftOffRequest, $employeeAssignment));
end
rule "shiftOnRequest"
    when
        $shiftOnRequest : ShiftOnRequest($employee : employee, $shift : shift, $weight : weight)
        not EmployeeAssignment(employee == $employee, shift == $shift)
    then
        insertLogical(new IntConstraintOccurrence("shiftOnRequest", ConstraintType.NEGATIVE_SOFT,
                $weight,
                $shiftOnRequest));
end

// Alternative skill
rule "alternativeSkill"
    when
        BooleanContractLine(contractLineType == ContractLineType.ALTERNATIVE_SKILL_CATEGORY, $contract : contract)
        $employeeAssignment : EmployeeAssignment(contract == $contract, $employee : employee, $shiftType : shiftType)
        ShiftTypeSkillRequirement(shiftType == $shiftType, $skill : skill)
        not SkillProficiency(employee == $employee, skill == $skill)
    then
        insertLogical(new IntConstraintOccurrence("alternativeSkill", ConstraintType.NEGATIVE_SOFT,
                1,
                $employeeAssignment));
end

// Unwanted patterns
// TODO

// ############################################################################
// Calculate score
// ############################################################################

// Accumulate hard constraints
rule "hardConstraintsBroken"
        salience -1 // Do the other rules first (optional, for performance)
    when
        $hardTotal : Number() from accumulate(
            IntConstraintOccurrence(constraintType == ConstraintType.NEGATIVE_HARD, $weight : weight),
            sum($weight) // Vote for http://jira.jboss.com/jira/browse/JBRULES-1075
        )
    then
        scoreCalculator.setHardConstraintsBroken($hardTotal.intValue());
end

// Accumulate soft constraints
rule "softConstraintsBroken"
        salience -1 // Do the other rules first (optional, for performance)
    when
        $softTotal : Number() from accumulate(
            IntConstraintOccurrence(constraintType == ConstraintType.NEGATIVE_SOFT, $weight : weight),
            sum($weight) // Vote for http://jira.jboss.com/jira/browse/JBRULES-1075
        )
    then
        scoreCalculator.setSoftConstraintsBroken($softTotal.intValue());
end
