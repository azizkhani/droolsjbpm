parser grammar DRLParser;

options {
	output=AST;
	tokenVocab=DRLLexer;
}

import DRLKeywords, Expression;

@header {
	package org.drools.lang;
	
	import java.util.List;
	import java.util.LinkedList;
	import org.drools.compiler.DroolsParserException;
}

@members {
    private ParserHelper helper = new ParserHelper( this,
                                                    tokenNames,
                                                    input,
                                                    state );
                                                    
    /**
     * The dummy parameter bellow is just to enable constructor overloading
     * so that we can initialise the parser helper on delegate grammars
     */
    public DRLParser(TokenStream input, boolean dummy ) {
        this(input);
        gDRLKeywords.setParserHelper( helper );
        gExpression.setParserHelper( helper );         
    }

    public ParserHelper getHelper()                           { return helper; }
    public boolean hasErrors()                                { return helper.hasErrors(); }
    public List<DroolsParserException> getErrors()            { return helper.getErrors(); }
    public List<String> getErrorMessages()                    { return helper.getErrorMessages(); }
    public void enableEditorInterface()                       {        helper.enableEditorInterface(); }
    public void disableEditorInterface()                      {        helper.disableEditorInterface(); }
    public LinkedList<DroolsSentence> getEditorInterface()    { return helper.getEditorInterface(); }
    public void reportError(RecognitionException ex)          {        helper.reportError( ex ); }

}
 
// --------------------------------------------------------
//                      MAIN RULE
// --------------------------------------------------------
compilation_unit
	:	package_statement?
		statement*
		EOF
		-> ^(VT_COMPILATION_UNIT package_statement? statement*) 
	;
	catch [ RecognitionException e ] {
		helper.reportError( e );
	}
	catch [ RewriteEmptyStreamException e ] {
	}
finally {
	if (helper.isEditorInterfaceEnabled && retval.tree == null) {
		retval.tree = root_0;
		root_0 = (Object) adaptor.nil();
		Object root_1 = (Object) adaptor.nil();
		root_1 = (Object) adaptor.becomeRoot(adaptor.create(
				VT_COMPILATION_UNIT, "VT_COMPILATION_UNIT"), root_1);
		if (stream_package_statement.hasNext()) {
			adaptor.addChild(root_1, stream_package_statement.nextTree());
		}
		while (stream_statement.hasNext()) {
			adaptor.addChild(root_1, stream_statement.nextTree());
		}
		adaptor.addChild(root_0, root_1);
		retval.stop = input.LT(-1);
		retval.tree = (Object) adaptor.rulePostProcessing(root_0);
		adaptor.setTokenBoundaries(retval.tree, retval.start,
				retval.stop);
	}
	if (helper.isEditorInterfaceEnabled && helper.hasErrors()) {
		Tree rootNode = (Tree) adaptor.becomeRoot(adaptor.create(
				VT_COMPILATION_UNIT, "VT_COMPILATION_UNIT"), adaptor.nil());
		for (int i = 0; i < ((Tree)retval.tree).getChildCount(); i++) {
			Tree childNode = (Tree) ((Tree)retval.tree).getChild(i);
			if (!(childNode instanceof CommonErrorNode)) {
				rootNode.addChild(childNode);
			}
		}
		retval.tree = rootNode; 
	}
}

// --------------------------------------------------------
//                      PACKAGE STATEMENT
// --------------------------------------------------------
package_statement
@init  { helper.pushParaphrases(DroolsParaphraseTypes.PACKAGE); if ( state.backtracking==0 ) helper.beginSentence(DroolsSentenceType.PACKAGE); }
@after { helper.popParaphrases(); }
	:	package_key
		packageOrTypeName SEMICOLON?
	{	helper.emit($SEMICOLON, DroolsEditorType.SYMBOL);	}
		-> ^(package_key packageOrTypeName)
	;



// --------------------------------------------------------
//                      GENERAL STATEMENT
// --------------------------------------------------------
statement
options{
k = 2;
}	:	{helper.validateLT(1, DroolsSoftKeywords.IMPORT) && helper.validateLT(2, DroolsSoftKeywords.FUNCTION)}?=> function_import_statement 
	|	{helper.validateLT(1, DroolsSoftKeywords.IMPORT)}?=>   import_statement 
	|	{helper.validateLT(1, DroolsSoftKeywords.GLOBAL)}?=>   global 
	|	{helper.validateLT(2, DroolsSoftKeywords.FUNCTION)}?=> function
	|	{helper.validateLT(1, DroolsSoftKeywords.DECLARE)}?=>  type_declaration
	|	{helper.validateLT(1, DroolsSoftKeywords.RULE)}?=>     rule
	|	{helper.validateLT(1, DroolsSoftKeywords.QUERY)}?=>    query
	|   rule_attribute
	;

// --------------------------------------------------------
//                      IMPORT STATEMENTS
// --------------------------------------------------------
import_statement
@init  { helper.pushParaphrases(DroolsParaphraseTypes.IMPORT); if ( state.backtracking==0 ) helper.beginSentence(DroolsSentenceType.IMPORT_STATEMENT);  }
@after { helper.popParaphrases(); }
	:	import_key import_name[DroolsParaphraseTypes.IMPORT] SEMICOLON?
	{	helper.emit($SEMICOLON, DroolsEditorType.SYMBOL);	}
		-> ^(import_key import_name)
	;

function_import_statement
@init  { helper.pushParaphrases(DroolsParaphraseTypes.FUNCTION_IMPORT); if ( state.backtracking==0 ) helper.beginSentence(DroolsSentenceType.FUNCTION_IMPORT_STATEMENT); }
@after { helper.popParaphrases(); }
	:	imp=import_key function_key import_name[DroolsParaphraseTypes.FUNCTION_IMPORT] SEMICOLON?
	{	helper.emit($SEMICOLON, DroolsEditorType.SYMBOL);	}		
		-> ^(VT_FUNCTION_IMPORT[$imp.start] function_key import_name)
	;

import_name [DroolsParaphraseTypes importType]
	:	id+=ID ( id+=DOT id+=ID )* id+=DOT_STAR?
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue($importType, helper.buildStringFromTokens($id));	}
		-> ^(VT_IMPORT_ID ID+ DOT_STAR?)
	;

// --------------------------------------------------------
//                      GLOBAL STATEMENT
// --------------------------------------------------------
global
@init  { helper.pushParaphrases(DroolsParaphraseTypes.GLOBAL);  if ( state.backtracking==0 ) helper.beginSentence(DroolsSentenceType.GLOBAL); }
@after { helper.popParaphrases(); }
	:	global_key data_type global_id SEMICOLON?
	{	helper.emit($SEMICOLON, DroolsEditorType.SYMBOL);	}
		-> ^(global_key data_type global_id)
	;

global_id
	:	id=ID
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue(DroolsParaphraseTypes.GLOBAL, $id.text);	}
		-> VT_GLOBAL_ID[$id]
	;

// --------------------------------------------------------
//                      FUNCTION STATEMENT
// --------------------------------------------------------
function
@init  { helper.pushParaphrases(DroolsParaphraseTypes.FUNCTION); if ( state.backtracking==0 ) helper.beginSentence(DroolsSentenceType.FUNCTION);  }
@after { helper.popParaphrases(); }
	:	function_key data_type? function_id parameters curly_chunk
		-> ^(function_key data_type? function_id parameters curly_chunk)
	;

function_id
	:	id=ID
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue(DroolsParaphraseTypes.FUNCTION, $id.text);	}
		-> VT_FUNCTION_ID[$id]
	;

// --------------------------------------------------------
//                      QUERY STATEMENT
// --------------------------------------------------------
query
@init  { helper.pushParaphrases(DroolsParaphraseTypes.QUERY); if ( state.backtracking==0 ) helper.beginSentence(DroolsSentenceType.QUERY); }
@after { helper.popParaphrases(); }
	:	query_key query_id 
	{	helper.emit(Location.LOCATION_RULE_HEADER);	}
		parameters? 
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);	}
		normal_lhs_block 
		end=end_key SEMICOLON?
	{	helper.emit($SEMICOLON, DroolsEditorType.SYMBOL);	}
		-> ^(query_key query_id parameters? normal_lhs_block end_key)
	;

query_id
	: 	id=ID
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue(DroolsParaphraseTypes.QUERY, $id.text);	} -> VT_QUERY_ID[$id]
	| 	id=STRING
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue(DroolsParaphraseTypes.QUERY, $id.text);	} -> VT_QUERY_ID[$id]
	;

// --------------------------------------------------------
//                      DECLARE STATEMENT
// --------------------------------------------------------
type_declaration
@init  { helper.pushParaphrases(DroolsParaphraseTypes.TYPE_DECLARE); if ( state.backtracking==0 ) helper.beginSentence(DroolsSentenceType.TYPE_DECLARATION); }
@after { helper.popParaphrases(); }
	:	declare_key  type_declare_id
		decl_metadata*
		decl_field*
		end_key
		-> ^(declare_key type_declare_id decl_metadata* decl_field* end_key)
	;

type_declare_id
	: 	id=ID
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue(DroolsParaphraseTypes.TYPE_DECLARE, $id.text);	} -> VT_TYPE_DECLARE_ID[$id]
	;

decl_metadata
	:	AT 
	{	helper.emit($AT, DroolsEditorType.SYMBOL);	}
		ID
	{	helper.emit($ID, DroolsEditorType.IDENTIFIER);	}
		paren_chunk?
		-> ^(AT ID paren_chunk?)
	;

decl_field
	:	ID	{	helper.emit($ID, DroolsEditorType.IDENTIFIER);	}
		decl_field_initialization? 
		COLON	{	helper.emit($COLON, DroolsEditorType.SYMBOL);	}
		data_type
		decl_metadata*
		-> ^(ID decl_field_initialization? data_type decl_metadata*)
	;

decl_field_initialization
	:	EQUALS_ASSIGN	{	helper.emit($EQUALS_ASSIGN, DroolsEditorType.SYMBOL);	}
		paren_chunk
	-> ^(EQUALS_ASSIGN paren_chunk)
	;

// --------------------------------------------------------
//                      RULE STATEMENT
// --------------------------------------------------------
rule
@init  { boolean isFailed = true; helper.pushParaphrases(DroolsParaphraseTypes.RULE); }
@after { helper.popParaphrases(); isFailed = false; }
	:
	{	helper.beginSentence(DroolsSentenceType.RULE);	}
		rule_key rule_id 
	{	helper.emit(Location.LOCATION_RULE_HEADER);	}
		(extend_key rule_id)? decl_metadata* rule_attributes? when_part? rhs_chunk
		-> ^(rule_key rule_id ^(extend_key rule_id)? decl_metadata* rule_attributes? when_part? rhs_chunk)
	;
finally {
	if (helper.isEditorInterfaceEnabled && isFailed) {
		if (input.LA(6) == EOF && input.LA(1) == ID && input.LA(2) == MINUS && input.LA(3) == ID && 
			input.LA(5) == MINUS && input.LA(6) == ID && 
			helper.validateLT(1, DroolsSoftKeywords.LOCK) && helper.validateLT(3, DroolsSoftKeywords.ON) &&
			helper.validateLT(5, DroolsSoftKeywords.ACTIVE)){
			helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
			helper.emit(input.LT(2), DroolsEditorType.KEYWORD);
			helper.emit(input.LT(3), DroolsEditorType.KEYWORD);
			helper.emit(input.LT(4), DroolsEditorType.KEYWORD);
			helper.emit(input.LT(5), DroolsEditorType.KEYWORD);
			helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);
			input.consume();
			input.consume();
			input.consume();
			input.consume();
			input.consume();
		} else if (input.LA(4) == EOF && input.LA(1) == ID && input.LA(2) == MINUS && input.LA(3) == ID && 
			(	(helper.validateLT(1, DroolsSoftKeywords.ACTIVATION) && helper.validateLT(3, DroolsSoftKeywords.GROUP)) ||
				(helper.validateLT(1, DroolsSoftKeywords.DATE) && helper.validateLT(3, DroolsSoftKeywords.EXPIRES)) ||
				(helper.validateLT(1, DroolsSoftKeywords.NO) && helper.validateLT(3, DroolsSoftKeywords.LOOP)) ||
				(helper.validateLT(1, DroolsSoftKeywords.DATE) && helper.validateLT(3, DroolsSoftKeywords.EFFECTIVE)) ||
				(helper.validateLT(1, DroolsSoftKeywords.AUTO) && helper.validateLT(3, DroolsSoftKeywords.FOCUS)) ||
				(helper.validateLT(1, DroolsSoftKeywords.ACTIVATION) && helper.validateLT(3, DroolsSoftKeywords.GROUP)) ||
				(helper.validateLT(1, DroolsSoftKeywords.RULEFLOW) && helper.validateLT(3, DroolsSoftKeywords.GROUP)) ||
				(helper.validateLT(1, DroolsSoftKeywords.AGENDA) && helper.validateLT(3, DroolsSoftKeywords.GROUP))	)){
			helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
			helper.emit(input.LT(2), DroolsEditorType.KEYWORD);
			helper.emit(input.LT(3), DroolsEditorType.KEYWORD);
			helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);
			input.consume();
			input.consume();
			input.consume();
		} else if (input.LA(2) == EOF && input.LA(1) == ID && 
				(helper.validateLT(1, DroolsSoftKeywords.DIALECT) || helper.validateLT(1, DroolsSoftKeywords.ENABLED) ||
				 helper.validateLT(1, DroolsSoftKeywords.SALIENCE) || helper.validateLT(1, DroolsSoftKeywords.DURATION) ||
				 helper.validateLT(1, DroolsSoftKeywords.TIMER))){
			helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
			helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);
			input.consume();
		}
	}
}

when_part
	: 	WHEN {	helper.emit($WHEN, DroolsEditorType.KEYWORD);	}
		COLON? {	helper.emit($COLON, DroolsEditorType.SYMBOL);	}
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);	}
		normal_lhs_block
	->	WHEN normal_lhs_block
	;

rule_id
	: 	id=ID
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue(DroolsParaphraseTypes.RULE, $id.text);	} -> VT_RULE_ID[$id]
	| 	id=STRING
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue(DroolsParaphraseTypes.RULE, $id.text);	} -> VT_RULE_ID[$id]
	;

rule_attributes
	:	( attributes_key COLON {	helper.emit($COLON, DroolsEditorType.SYMBOL);	} )? 
		rule_attribute ( COMMA? {	helper.emit($COMMA, DroolsEditorType.SYMBOL);	} attr=rule_attribute )*
		-> ^(VT_RULE_ATTRIBUTES attributes_key? rule_attribute+)
	;

rule_attribute
@init  { boolean isFailed = true; helper.pushParaphrases(DroolsParaphraseTypes.RULE_ATTRIBUTE); }
@after { helper.popParaphrases(); isFailed = false; if (!(retval.tree instanceof CommonErrorNode)) helper.emit(Location.LOCATION_RULE_HEADER); }
	:	salience 
	|	no_loop
	|	agenda_group  
	|	timer  
	|	activation_group 
	|	auto_focus 
	|	date_effective 
	|	date_expires 
	|	enabled 
	|	ruleflow_group 
	|	lock_on_active
	|	dialect 
	|       calendars
	;
finally {
	if (helper.isEditorInterfaceEnabled && isFailed) {
		if (input.LA(2) == EOF && input.LA(1) == ID){
			helper.emit(input.LT(1), DroolsEditorType.IDENTIFIER);
			input.consume();
		}
	}
}
date_effective
	:	date_effective_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} STRING
	{	helper.emit($STRING, DroolsEditorType.STRING_CONST );	}
	;

date_expires
	:	date_expires_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} STRING
	{	helper.emit($STRING, DroolsEditorType.STRING_CONST );	}
	;
	
enabled
	:	enabled_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} 
	    ( BOOL {	helper.emit($BOOL, DroolsEditorType.BOOLEAN_CONST );	}
	    | paren_chunk 
	    )
	;	

salience
	:	salience_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	}
		( DECIMAL 	{	helper.emit($DECIMAL, DroolsEditorType.NUMERIC_CONST );	}
		| paren_chunk
		)
	;

no_loop
	:	no_loop_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} BOOL?
	{	helper.emit($BOOL, DroolsEditorType.BOOLEAN_CONST );	}
	;

auto_focus
	:	auto_focus_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} BOOL?
	{	helper.emit($BOOL, DroolsEditorType.BOOLEAN_CONST );	}
	;	
	
activation_group
	:	activation_group_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} STRING
	{	helper.emit($STRING, DroolsEditorType.STRING_CONST );	}
	;

ruleflow_group
	:	ruleflow_group_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} STRING
	{	helper.emit($STRING, DroolsEditorType.STRING_CONST );	}
	;

agenda_group
	:	agenda_group_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} STRING
	{	helper.emit($STRING, DroolsEditorType.STRING_CONST );	}
	;

timer
	:	(duration_key^|timer_key^) {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} 
	    	( DECIMAL {	helper.emit($DECIMAL, DroolsEditorType.NUMERIC_CONST );	}
	    	| paren_chunk
	    	)
	;	
	
calendars
	:	calendars_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} string_list
	;

dialect
	:	dialect_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} STRING
	{	helper.emit($STRING, DroolsEditorType.STRING_CONST );	}
	;			
	
lock_on_active
	:	lock_on_active_key^ {	helper.emit(Location.LOCATION_RULE_HEADER_KEYWORD);	} BOOL?
	{	helper.emit($BOOL, DroolsEditorType.BOOLEAN_CONST );	}
	;

// --------------------------------------------------------
//                      LHS
// --------------------------------------------------------
normal_lhs_block
	:	lhs*
	->	^(VT_AND_IMPLICIT lhs*)
	;

lhs	:	lhs_or
	;

lhs_or
@init{
	Token orToken = null;
}	:	(LEFT_PAREN or_key)=> 
		LEFT_PAREN  {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	}
			or=or_key
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);	}
			lhs_and+ 
		RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	} // PREFIX 
		-> ^(VT_OR_PREFIX[$or.start] lhs_and+ RIGHT_PAREN)
	|	(lhs_and -> lhs_and) 
		( (or_key)=> (value=or_key {orToken = $value.start;} ) 
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);	}
		lhs_and 
		-> ^(VT_OR_INFIX[orToken] $lhs_or lhs_and))*
	;

lhs_and
@init{
	Token andToken = null;
}	:	(LEFT_PAREN and_key)=> 
		LEFT_PAREN {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	} 
			and=and_key
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);	}
			lhs_unary+ 
		RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}  // PREFIX
		-> ^(VT_AND_PREFIX[$and.start] lhs_unary+ RIGHT_PAREN)
	|	(lhs_unary -> lhs_unary) 
		( (and_key)=> (value=and_key {andToken = $value.start;} ) 
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_AND_OR);	}
		lhs_unary 
		-> ^(VT_AND_INFIX[andToken] $lhs_and lhs_unary) )*
	;

lhs_unary
	:	(	lhs_exist
		|{helper.validateNotWithBinding()}?=>	lhs_not_binding
		|	lhs_not
		|	lhs_eval
		|	lhs_forall
		|	LEFT_PAREN! {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL); helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION );	}  
				lhs_or 
			RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
		|	pattern_source
		)
		((SEMICOLON)=> SEMICOLON! {	helper.emit($SEMICOLON, DroolsEditorType.SYMBOL);	})?
	;

lhs_exist
	:	exists_key
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_EXISTS);	}
	        ( (LEFT_PAREN (or_key|and_key))=> lhs_or //prevent "((" 
		| LEFT_PAREN {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	} 
			lhs_or 
		  RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
	        | lhs_pattern
	        )
	        -> ^(exists_key lhs_or? lhs_pattern? RIGHT_PAREN?)
	;

lhs_not_binding
	:	not_key fact_binding
	-> ^(not_key ^(VT_PATTERN fact_binding))
	;

lhs_not	:	not_key
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION_NOT);	}
		( (LEFT_PAREN (or_key|and_key))=> {	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION );	} lhs_or //prevent "((" 
		|	LEFT_PAREN {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL); helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION );	} 
				lhs_or 
			RIGHT_PAREN  {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
		| 	lhs_pattern )
	        -> ^(not_key lhs_or? lhs_pattern? RIGHT_PAREN?)
	;

lhs_eval
	:	ev=eval_key
	{	helper.emit(Location.LOCATION_LHS_INSIDE_EVAL);	}
		pc=paren_chunk
	{	if (((DroolsTree) $pc.tree).getText() != null){
			helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);	            		
		}
	}
	{	String body = helper.safeSubstring( $pc.text, 1, $pc.text.length()-1 );
		helper.checkTrailingSemicolon( body, $ev.start );	}
		-> ^(eval_key paren_chunk)
	;

lhs_forall
	:	forall_key 
		LEFT_PAREN {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	} 
			pattern_source+ 
		RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
		-> ^(forall_key pattern_source+ RIGHT_PAREN)
	;

pattern_source
@init { boolean isFailed = true;	}
@after { isFailed = false;	}
	:	lhs_pattern
		over_clause?
		(
			FROM^
		{	helper.emit($FROM, DroolsEditorType.KEYWORD);
			helper.emit(Location.LOCATION_LHS_FROM);	}
		        (  accumulate_statement
		          | collect_statement 
		          | entrypoint_statement
		          | from_source
		        )
		)?
	;
finally {
	if (helper.isEditorInterfaceEnabled && input.LA(3) == EOF && input.LA(1) == ACCUMULATE) {
			helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
			helper.emit(input.LT(2), DroolsEditorType.SYMBOL);
			input.consume();
			helper.emit(true, Location.LOCATION_LHS_FROM_ACCUMULATE);
	} else if (helper.isEditorInterfaceEnabled && input.LA(3) == EOF && input.LA(1) == COLLECT) {
			helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
			helper.emit(input.LT(2), DroolsEditorType.SYMBOL);
			input.consume();
			helper.emit(true, Location.LOCATION_LHS_FROM_COLLECT);
	}
}

over_clause
	:	OVER^ {	helper.emit($OVER, DroolsEditorType.KEYWORD);	} over_elements 
			(COMMA! {	helper.emit($COMMA, DroolsEditorType.SYMBOL);	} over_elements)*
	;

over_elements
	:	id1=ID {	helper.emit($id1, DroolsEditorType.IDENTIFIER);	} 
		COLON {	helper.emit($COLON, DroolsEditorType.SYMBOL);	} 
		id2=ID {	helper.emit($id2, DroolsEditorType.IDENTIFIER);	} 
		paren_chunk
	-> ^(VT_BEHAVIOR $id1 $id2 paren_chunk)
	;

accumulate_statement
	:	ACCUMULATE {	helper.emit($ACCUMULATE, DroolsEditorType.KEYWORD);	}
	{	helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE);	}
		LEFT_PAREN {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	} 
			lhs_or 
		COMMA? {	helper.emit($COMMA, DroolsEditorType.SYMBOL);	} 
		(	accumulate_init_clause
		|	accumulate_id_clause
		)
		RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);	}
		-> ^(ACCUMULATE lhs_or accumulate_init_clause? accumulate_id_clause? RIGHT_PAREN)
	;


accumulate_init_clause
@init  { boolean isFailed = true;	}
@after { isFailed = false;	}
	:	init_key 
	{	helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_INIT);	}
		pc1=accumulate_paren_chunk[Location.LOCATION_LHS_FROM_ACCUMULATE_INIT_INSIDE] cm1=COMMA? {	helper.emit($cm1, DroolsEditorType.SYMBOL);	} 
	{	if (pc1 != null && ((DroolsTree) pc1.getTree()).getText() != null) helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_ACTION);	}
		action_key pc2=accumulate_paren_chunk[Location.LOCATION_LHS_FROM_ACCUMULATE_ACTION_INSIDE] cm2=COMMA? {	helper.emit($cm2, DroolsEditorType.SYMBOL);	} 
	{	if (pc1 != null && ((DroolsTree) pc1.getTree()).getText() != null && pc2 != null && ((DroolsTree) pc2.getTree()).getText() != null ) helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_REVERSE);	}
	(	reverse_key pc3=accumulate_paren_chunk[Location.LOCATION_LHS_FROM_ACCUMULATE_REVERSE_INSIDE] cm3=COMMA? {	helper.emit($cm3, DroolsEditorType.SYMBOL);	} )?

	{	if ((pc1 != null && ((DroolsTree) pc1.tree).getText() != null) &&
            			(pc2 != null && ((DroolsTree) pc2.tree).getText() != null) &&
            			(pc3 != null && ((DroolsTree) pc3.tree).getText() != null)) {
			helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT);
		}	
	}
		res1=result_key {	helper.emit($res1.start, DroolsEditorType.KEYWORD);	} pc4=accumulate_paren_chunk[Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT_INSIDE]
	-> ^(VT_ACCUMULATE_INIT_CLAUSE ^(init_key $pc1) ^(action_key $pc2) ^(reverse_key $pc3)? ^(result_key $pc4))
	;
finally { 
	if (helper.isEditorInterfaceEnabled && isFailed && input.LA(1) == ID && helper.validateLT(1, DroolsSoftKeywords.RESULT)) {
		helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
		input.consume();
		if (input.LA(1) == LEFT_PAREN){
			input.consume();
			helper.emit(Location.LOCATION_LHS_FROM_ACCUMULATE_RESULT_INSIDE);
		}
	}
}

accumulate_paren_chunk[int locationType]
@init{
	String text = "";
}	:	pc=accumulate_paren_chunk_data[false,$locationType] {text = $pc.text;} 
	-> VT_PAREN_CHUNK[$pc.start,text]
	;

accumulate_paren_chunk_data[boolean isRecursive, int locationType]
	:	lp1=LEFT_PAREN
		{	if (!isRecursive) {
				helper.emit($lp1, DroolsEditorType.SYMBOL);
				helper.emit($locationType);
			} else {
				helper.emit($lp1, DroolsEditorType.CODE_CHUNK);
			}	
		}
			(any=~ ( LEFT_PAREN | RIGHT_PAREN ) { helper.emit($any, DroolsEditorType.CODE_CHUNK); } | accumulate_paren_chunk_data[true,-1] )* 
		rp1=RIGHT_PAREN
		{	if (!isRecursive) {
				helper.emit($rp1, DroolsEditorType.SYMBOL);
			} else {
				helper.emit($rp1, DroolsEditorType.CODE_CHUNK);
			}	
		}	
	;

accumulate_id_clause
	:	ID {	helper.emit($ID, DroolsEditorType.IDENTIFIER);	}
		paren_chunk
	-> ^(VT_ACCUMULATE_ID_CLAUSE ID paren_chunk)
	;

collect_statement
	:	COLLECT {	helper.emit($COLLECT, DroolsEditorType.KEYWORD);	}
	{	helper.emit(Location.LOCATION_LHS_FROM_COLLECT);	}
		LEFT_PAREN {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	}
			pattern_source 
		RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);	}
	-> ^(COLLECT pattern_source RIGHT_PAREN)
	;

entrypoint_statement
	:	entry_point_key 
	{	helper.emit(Location.LOCATION_LHS_FROM_COLLECT);	}
		entrypoint_id
	{	helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);	}
	-> ^(entry_point_key entrypoint_id)
	;

entrypoint_id
	: 	value=ID {	helper.emit($value, DroolsEditorType.IDENTIFIER);	}
		-> VT_ENTRYPOINT_ID[$value]
	| 	value=STRING {	helper.emit($value, DroolsEditorType.IDENTIFIER);	}
		-> VT_ENTRYPOINT_ID[$value]
	;


from_source
	:	fs=expression  -> VT_FROM_SOURCE[$fs.text]
	;

/*from_source_matcher
	:       ( ID
 		| square_chunk
	 	| {input.LA(1) == LEFT_PAREN}? args=paren_chunk )
		expression_chain?
	;

expression_chain
	:       ( DOT ID
		| square_chunk
		| {input.LA(1) == LEFT_PAREN}? paren_chunk )
		expression_chain?
	;


( ID {	helper.emit($ID, DroolsEditorType.IDENTIFIER);	}
		     ( (LEFT_PAREN)=> args=paren_chunk )?
     		     expression_chain?
	             {	if ( input.LA(1) == EOF && input.get(input.index() - 1).getType() == WS) {
			    helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
		        } else if ( input.LA(1) != EOF ) {
			    helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
		        }	
		     }
   		  ->	^(VT_FROM_SOURCE ID paren_chunk? expression_chain?)
   		 )
   		 |
   		 ( square_chunk expression_chain? -> ^(VT_FROM_SOURCE square_chunk expression_chain? ) )
	;
	
expression_chain
	:
	  DOT {	helper.emit($DOT, DroolsEditorType.IDENTIFIER);	} 
      	    ID {	helper.emit($ID, DroolsEditorType.IDENTIFIER);	} 
	  (
	    {input.LA(1) == LEFT_PAREN}? paren_chunk
	    |
	    square_chunk
	  )?
	  expression_chain?
	  -> ^(VT_EXPRESSION_CHAIN[$DOT] ID square_chunk? paren_chunk? expression_chain?)
	;
*/

// --------------------------------------------------------
//                      PATTERN
// --------------------------------------------------------
lhs_pattern
	:	fact_binding -> ^(VT_PATTERN fact_binding)
	|	fact -> ^(VT_PATTERN fact)
	;

fact_binding
 	:	label
		( fact
 		| LEFT_PAREN {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	}
 			fact_binding_expression 
 		  RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
 		)
 	-> ^(VT_FACT_BINDING label fact? fact_binding_expression? RIGHT_PAREN?)
	;

fact_binding_expression
@init{
	Token orToken = null;
}	:	(fact -> fact) ( (value=or_key {orToken = $value.start;}|pipe=DOUBLE_PIPE {orToken = $pipe;}) fact 
		-> ^(VT_FACT_OR[orToken] $fact_binding_expression fact) )*
	;

fact
@init  { boolean isFailedOnConstraints = true; helper.pushParaphrases(DroolsParaphraseTypes.PATTERN); }
@after { helper.popParaphrases();	}
	:	pattern_type 
		LEFT_PAREN {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	} 
	{	helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_START);	}
			constraints? 
		RIGHT_PAREN {	isFailedOnConstraints = false;	}
	{	if ($RIGHT_PAREN.text.equals(")") ){ //WORKAROUND FOR ANTLR BUG!
			helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);
			helper.emit(Location.LOCATION_LHS_BEGIN_OF_CONDITION);
		}	}
	->	^(VT_FACT pattern_type constraints? RIGHT_PAREN)
	;
finally {
	if (helper.isEditorInterfaceEnabled && isFailedOnConstraints && input.LA(1) == EOF && input.get(input.index() - 1).getType() == WS){
		if (!(helper.getActiveSentence().getContent().getLast() instanceof Integer) && input.LA(-1) != COLON) {
			helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
		}
	}
}

constraints
	:	constraint ( COMMA! 
	{	helper.emit($COMMA, DroolsEditorType.SYMBOL);
		helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_START);	} constraint )*
	;

constraint
	:	or_constr
	;

or_constr
	:	and_constr ( DOUBLE_PIPE^ 
	{	helper.emit($DOUBLE_PIPE, DroolsEditorType.SYMBOL);	} and_constr )* 
	;

and_constr
	:	unary_constr ( DOUBLE_AMPER^ 
	{	helper.emit($DOUBLE_AMPER, DroolsEditorType.SYMBOL);;	} unary_constr )*
	;

unary_constr
options { k=2; }
@init { boolean isFailed = true;	}
@after { isFailed = false;	}
	:	eval_key^ paren_chunk
	|	field_constraint
	| 	LEFT_PAREN! {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	}  
			or_constr 
		RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
	;
finally { 
	if (helper.isEditorInterfaceEnabled && isFailed && input.LA(2) == EOF && input.LA(1) == ID) {
		helper.emit(input.LT(1), DroolsEditorType.IDENTIFIER);
		input.consume();
		if (input.get(input.index() - 1).getType() == WS)
			helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
	}
}

field_constraint
@init{
	boolean isArrow = false;
}	:	label accessor_path 
		( or_restr_connective | arw=ARROW {	helper.emit($ARROW, DroolsEditorType.SYMBOL);	} paren_chunk {isArrow = true;})?
		-> {isArrow}? ^(VT_BIND_FIELD label ^(VT_FIELD accessor_path)) ^(VK_EVAL[$arw] paren_chunk)?
		-> ^(VT_BIND_FIELD label ^(VT_FIELD accessor_path or_restr_connective?))
	|	accessor_path or_restr_connective
		-> ^(VT_FIELD accessor_path or_restr_connective)
	;

label
	:	value=ID {	helper.emit($ID, DroolsEditorType.IDENTIFIER_VARIABLE);	} 
		COLON {	helper.emit($COLON, DroolsEditorType.SYMBOL);	} 
		-> VT_LABEL[$value]
	;

or_restr_connective
	:	and_restr_connective ({(helper.validateRestr())}?=> DOUBLE_PIPE^ 
	{	helper.emit($DOUBLE_PIPE, DroolsEditorType.SYMBOL);	}  and_restr_connective )* 
	;
catch [ RecognitionException re ] {
	if (!helper.lookaheadTest){
        helper.reportError(re);
        recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
	} else {
		throw re;
	}
}

and_restr_connective
	:	constraint_expression ({(helper.validateRestr())}?=> DOUBLE_AMPER^ 
	{	helper.emit($DOUBLE_AMPER, DroolsEditorType.SYMBOL);	} constraint_expression )*
	;
catch [ RecognitionException re ] {
	if (!helper.lookaheadTest){
        helper.reportError(re);
        recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
	} else {
		throw re;
	}
}

constraint_expression
options{ k=3; }	
	:	compound_operator
	|	simple_operator
	|	LEFT_PAREN! {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	} 
			or_restr_connective 
		RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	} 
	;
catch [ RecognitionException re ] {
	if (!helper.lookaheadTest){
        helper.reportError(re);
        recover(input,re);
    	retval.tree = (Object)adaptor.errorNode(input, retval.start, input.LT(-1), re);
	} else {
		throw re;
	}
}
finally {
	if (helper.isEditorInterfaceEnabled && input.LA(2) == EOF && input.LA(1) == ID) {
		helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
		helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
		input.consume();
		helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
	} else if (helper.isEditorInterfaceEnabled && input.LA(3) == EOF && input.LA(1) == ID && 
				input.LA(2) == ID && helper.validateLT(1, DroolsSoftKeywords.NOT)) {
		helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
		helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
		helper.emit(input.LT(2), DroolsEditorType.KEYWORD);
		input.consume();
		input.consume();
		helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
	} else if (helper.isEditorInterfaceEnabled && input.LA(3) == EOF  && input.LA(1) == ID && helper.validateLT(1, DroolsSoftKeywords.IN)) {
		helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
		helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
		helper.emit(input.LT(2), DroolsEditorType.SYMBOL);
		input.consume();
		input.consume();
		helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);
	} else if (helper.isEditorInterfaceEnabled && input.LA(3) == EOF && input.LA(1) == ID) {
		helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
		helper.emit(input.LT(1), DroolsEditorType.KEYWORD);
		helper.emit(input.LT(2), DroolsEditorType.IDENTIFIER);
		input.consume();
		input.consume();
		if (input.get(input.index() - 1).getType() == WS){
			helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_END);
		}
	}
}

simple_operator
@init {if ( state.backtracking==0 ) helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);}
	:	
	(
		EQUALS^ {	helper.emit($EQUALS, DroolsEditorType.SYMBOL);	}
	|	GREATER^ {	helper.emit($GREATER, DroolsEditorType.SYMBOL);	}
	|	GREATER_EQUALS^ {	helper.emit($GREATER_EQUALS, DroolsEditorType.SYMBOL);	}
	|	LESS^ {	helper.emit($LESS, DroolsEditorType.SYMBOL);	}
	|	LESS_EQUALS^ {	helper.emit($LESS_EQUALS, DroolsEditorType.SYMBOL);	}
	|	NOT_EQUALS^ {	helper.emit($NOT_EQUALS, DroolsEditorType.SYMBOL);	}
	|	not_key?
		(	operator_key^ square_chunk?	)
	)
	{	helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);	}
	expression_value
	;

//Simple Syntax Sugar
compound_operator 
@init { if ( state.backtracking==0 ) helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR); }
	:	
	( in_key^ | not_key in_key^ ) 
	{	helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT);	}
		LEFT_PAREN! {	helper.emit($LEFT_PAREN, DroolsEditorType.SYMBOL);	}
			expression_value ( COMMA! {	helper.emit($COMMA, DroolsEditorType.SYMBOL);	} expression_value )* 
		RIGHT_PAREN {	helper.emit($RIGHT_PAREN, DroolsEditorType.SYMBOL);	}
	{	helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_END);	}
	;
finally { 
	if (helper.isEditorInterfaceEnabled && input.LA(2) == EOF && input.LA(1) == DOUBLE_PIPE) {
		helper.emit(input.LT(1), DroolsEditorType.SYMBOL);
		input.consume();
		helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
	}	}

expression_value
	:	(accessor_path
	|	literal 
	|	paren_chunk)
	{	if (helper.isEditorInterfaceEnabled && !(input.LA(1) == EOF && input.get(input.index() - 1).getType() != WS))
			helper.emit(Location.LOCATION_LHS_INSIDE_CONDITION_END);	}
	;
finally { 
	if (helper.isEditorInterfaceEnabled && input.LA(2) == EOF) {
		if (input.LA(1) == DOUBLE_PIPE) {
			helper.emit(input.LT(1), DroolsEditorType.SYMBOL);
			input.consume();
			helper.emit(true, Location.LOCATION_LHS_INSIDE_CONDITION_OPERATOR);
		}
	}
}

pattern_type
	:	id+=ID ( id+=DOT id+=ID )* 
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);
		helper.setParaphrasesValue(DroolsParaphraseTypes.PATTERN, helper.buildStringFromTokens($id));	} 
	    dimension_definition*
		-> ^(VT_PATTERN_TYPE ID+ dimension_definition*)
	;

data_type
	:	id+=ID ( id+=DOT id+=ID )* dimension_definition*
	{	helper.emit($id, DroolsEditorType.IDENTIFIER);	}
		-> ^(VT_DATA_TYPE ID+ dimension_definition*)
	;

dimension_definition
	:	LEFT_SQUARE {	helper.emit($LEFT_SQUARE, DroolsEditorType.SYMBOL);	} 
		RIGHT_SQUARE {	helper.emit($RIGHT_SQUARE, DroolsEditorType.SYMBOL);	} 
	;

accessor_path
	:	accessor_element ( DOT {	helper.emit($DOT, DroolsEditorType.IDENTIFIER);	} accessor_element )*
	-> ^(VT_ACCESSOR_PATH accessor_element+)
	;

accessor_element
	:	ID {	helper.emit($ID, DroolsEditorType.IDENTIFIER);	}
		square_chunk*
	-> ^(VT_ACCESSOR_ELEMENT ID square_chunk*)
	;

// --------------------------------------------------------
//                      CHUNKS
// --------------------------------------------------------
rhs_chunk
@init{
	String text = "";
}	:	rc=rhs_chunk_data {text = $rc.text;}
	-> VT_RHS_CHUNK[$rc.start,text]
	;

rhs_chunk_data
	:	THEN 
	{	if ($THEN.text.equalsIgnoreCase("then")){
			helper.emit($THEN, DroolsEditorType.KEYWORD);
			helper.emit(Location.LOCATION_RHS);
		}	}
			not_end_key* 
		end_key 
		SEMICOLON? {	helper.emit($SEMICOLON, DroolsEditorType.KEYWORD);	}
	;

curly_chunk
@init{
	String text = "";
}	:	cc=curly_chunk_data[false] {text = $cc.text;}
	-> VT_CURLY_CHUNK[$cc.start,text]
	;

curly_chunk_data[boolean isRecursive]
	:	lc1=LEFT_CURLY
		{	if (!isRecursive) {
				helper.emit($lc1, DroolsEditorType.SYMBOL);
			} else {
				helper.emit($lc1, DroolsEditorType.CODE_CHUNK);
			}	
		}
			(any=~ ( LEFT_CURLY | RIGHT_CURLY ) { helper.emit($any, DroolsEditorType.CODE_CHUNK); } | curly_chunk_data[true] )* 
		rc1=RIGHT_CURLY
		{	if (!isRecursive) {
				helper.emit($rc1, DroolsEditorType.SYMBOL);
			} else {
				helper.emit($rc1, DroolsEditorType.CODE_CHUNK);
			}	
		}	
	;

paren_chunk
@init{
	String text = "";
}	:	pc=paren_chunk_data[false] {text = $pc.text;} 
	-> VT_PAREN_CHUNK[$pc.start,text]
	;

paren_chunk_data[boolean isRecursive]
	:	lp1=LEFT_PAREN
		{	if (!isRecursive) {
				helper.emit($lp1, DroolsEditorType.SYMBOL);
			} else {
				helper.emit($lp1, DroolsEditorType.CODE_CHUNK);
			}	
		}
			(any=~ ( LEFT_PAREN | RIGHT_PAREN ) { helper.emit($any, DroolsEditorType.CODE_CHUNK); } | paren_chunk_data[true] )* 
		rp1=RIGHT_PAREN
		{	if (!isRecursive) {
				helper.emit($rp1, DroolsEditorType.SYMBOL);
			} else {
				helper.emit($rp1, DroolsEditorType.CODE_CHUNK);
			}	
		}	
	;

square_chunk
@init{
	String text = "";
}	:	sc=square_chunk_data[false] {text = $sc.text;}
	-> VT_SQUARE_CHUNK[$sc.start,text]
	;

square_chunk_data[boolean isRecursive]
	:	ls1=LEFT_SQUARE
		{	if (!isRecursive) {
				helper.emit($ls1, DroolsEditorType.SYMBOL);
			} else {
				helper.emit($ls1, DroolsEditorType.CODE_CHUNK);
			}	
		}
			(any=~ ( LEFT_SQUARE | RIGHT_SQUARE ) { helper.emit($any, DroolsEditorType.CODE_CHUNK); }| square_chunk_data[true] )* 
		rs1=RIGHT_SQUARE
		{	if (!isRecursive) {
				helper.emit($rs1, DroolsEditorType.SYMBOL);
			} else {
				helper.emit($rs1, DroolsEditorType.CODE_CHUNK);
			}	
		}
	;
